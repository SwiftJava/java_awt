
import java_swift

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// JAVA_HOME: /Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home ///
/// Tue Dec 20 11:35:30 GMT 2016 ///

/// interface java.awt.im.spi.InputMethodContext ///

public protocol InputMethodContext: InputMethodRequests {

    /// public abstract java.awt.Window java.awt.im.spi.InputMethodContext.createInputMethodWindow(java.lang.String,boolean)

    func createInputMethodWindow( arg0: String?, arg1: Bool ) -> Window!
    func createInputMethodWindow( _ _arg0: String?, _ _arg1: Bool ) -> Window!

    /// public abstract void java.awt.im.spi.InputMethodContext.dispatchInputMethodEvent(int,java.text.AttributedCharacterIterator,int,java.awt.font.TextHitInfo,java.awt.font.TextHitInfo)

    func dispatchInputMethodEvent( arg0: Int, arg1: /* java.text.AttributedCharacterIterator */ UnclassedProtocol?, arg2: Int, arg3: TextHitInfo?, arg4: TextHitInfo? )
    func dispatchInputMethodEvent( _ _arg0: Int, _ _arg1: /* java.text.AttributedCharacterIterator */ UnclassedProtocol?, _ _arg2: Int, _ _arg3: TextHitInfo?, _ _arg4: TextHitInfo? )

    /// public abstract javax.swing.JFrame java.awt.im.spi.InputMethodContext.createInputMethodJFrame(java.lang.String,boolean)

    /// public abstract void java.awt.im.spi.InputMethodContext.enableClientWindowNotification(java.awt.im.spi.InputMethod,boolean)

    func enableClientWindowNotification( arg0: InputMethod?, arg1: Bool )
    func enableClientWindowNotification( _ _arg0: InputMethod?, _ _arg1: Bool )

}

open class InputMethodContextForward: InputMethodRequestsForward, InputMethodContext {

    private static var InputMethodContextJNIClass: jclass?

    /// public abstract java.awt.Window java.awt.im.spi.InputMethodContext.createInputMethodWindow(java.lang.String,boolean)

    private static var createInputMethodWindow_MethodID_4: jmethodID?

    open func createInputMethodWindow( arg0: String?, arg1: Bool ) -> Window! {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "createInputMethodWindow", methodSig: "(Ljava/lang/String;Z)Ljava/awt/Window;", methodCache: &InputMethodContextForward.createInputMethodWindow_MethodID_4, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? Window( javaObject: __return ) : nil
    }

    open func createInputMethodWindow( _ _arg0: String?, _ _arg1: Bool ) -> Window! {
        return createInputMethodWindow( arg0: _arg0, arg1: _arg1 )
    }

    /// public abstract void java.awt.im.spi.InputMethodContext.dispatchInputMethodEvent(int,java.text.AttributedCharacterIterator,int,java.awt.font.TextHitInfo,java.awt.font.TextHitInfo)

    private static var dispatchInputMethodEvent_MethodID_5: jmethodID?

    open func dispatchInputMethodEvent( arg0: Int, arg1: /* java.text.AttributedCharacterIterator */ UnclassedProtocol?, arg2: Int, arg3: TextHitInfo?, arg4: TextHitInfo? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 5 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = jvalue( l: arg1?.localJavaObject( &__locals ) )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        __args[3] = JNIType.encode( value: arg3, locals: &__locals )
        __args[4] = JNIType.encode( value: arg4, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "dispatchInputMethodEvent", methodSig: "(ILjava/text/AttributedCharacterIterator;ILjava/awt/font/TextHitInfo;Ljava/awt/font/TextHitInfo;)V", methodCache: &InputMethodContextForward.dispatchInputMethodEvent_MethodID_5, args: &__args, locals: &__locals )
    }

    open func dispatchInputMethodEvent( _ _arg0: Int, _ _arg1: /* java.text.AttributedCharacterIterator */ UnclassedProtocol?, _ _arg2: Int, _ _arg3: TextHitInfo?, _ _arg4: TextHitInfo? ) {
        dispatchInputMethodEvent( arg0: _arg0, arg1: _arg1, arg2: _arg2, arg3: _arg3, arg4: _arg4 )
    }

    /// public abstract javax.swing.JFrame java.awt.im.spi.InputMethodContext.createInputMethodJFrame(java.lang.String,boolean)

    /// public abstract void java.awt.im.spi.InputMethodContext.enableClientWindowNotification(java.awt.im.spi.InputMethod,boolean)

    private static var enableClientWindowNotification_MethodID_6: jmethodID?

    open func enableClientWindowNotification( arg0: InputMethod?, arg1: Bool ) {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "enableClientWindowNotification", methodSig: "(Ljava/awt/im/spi/InputMethod;Z)V", methodCache: &InputMethodContextForward.enableClientWindowNotification_MethodID_6, args: &__args, locals: &__locals )
    }

    open func enableClientWindowNotification( _ _arg0: InputMethod?, _ _arg1: Bool ) {
        enableClientWindowNotification( arg0: _arg0, arg1: _arg1 )
    }

    /// public abstract java.awt.Rectangle java.awt.im.InputMethodRequests.getTextLocation(java.awt.font.TextHitInfo)

    private static var getTextLocation_MethodID_7: jmethodID?

    override open func getTextLocation( arg0: TextHitInfo? ) -> Rectangle! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getTextLocation", methodSig: "(Ljava/awt/font/TextHitInfo;)Ljava/awt/Rectangle;", methodCache: &InputMethodContextForward.getTextLocation_MethodID_7, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? Rectangle( javaObject: __return ) : nil
    }

    override open func getTextLocation( _ _arg0: TextHitInfo? ) -> Rectangle! {
        return getTextLocation( arg0: _arg0 )
    }

    /// public abstract java.awt.font.TextHitInfo java.awt.im.InputMethodRequests.getLocationOffset(int,int)

    private static var getLocationOffset_MethodID_8: jmethodID?

    override open func getLocationOffset( arg0: Int, arg1: Int ) -> TextHitInfo! {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getLocationOffset", methodSig: "(II)Ljava/awt/font/TextHitInfo;", methodCache: &InputMethodContextForward.getLocationOffset_MethodID_8, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? TextHitInfo( javaObject: __return ) : nil
    }

    override open func getLocationOffset( _ _arg0: Int, _ _arg1: Int ) -> TextHitInfo! {
        return getLocationOffset( arg0: _arg0, arg1: _arg1 )
    }

    /// public abstract int java.awt.im.InputMethodRequests.getInsertPositionOffset()

    private static var getInsertPositionOffset_MethodID_9: jmethodID?

    override open func getInsertPositionOffset() -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getInsertPositionOffset", methodSig: "()I", methodCache: &InputMethodContextForward.getInsertPositionOffset_MethodID_9, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }


    /// public abstract java.text.AttributedCharacterIterator java.awt.im.InputMethodRequests.getCommittedText(int,int,java.text.AttributedCharacterIterator$Attribute[])

    /// public abstract int java.awt.im.InputMethodRequests.getCommittedTextLength()

    private static var getCommittedTextLength_MethodID_10: jmethodID?

    override open func getCommittedTextLength() -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getCommittedTextLength", methodSig: "()I", methodCache: &InputMethodContextForward.getCommittedTextLength_MethodID_10, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }


    /// public abstract java.text.AttributedCharacterIterator java.awt.im.InputMethodRequests.cancelLatestCommittedText(java.text.AttributedCharacterIterator$Attribute[])

    /// public abstract java.text.AttributedCharacterIterator java.awt.im.InputMethodRequests.getSelectedText(java.text.AttributedCharacterIterator$Attribute[])

    /// In declared protocol but not defined.. ///

    /// public abstract java.text.AttributedCharacterIterator java.awt.im.InputMethodRequests.cancelLatestCommittedText(java.text.AttributedCharacterIterator$Attribute[])

    /// public abstract java.text.AttributedCharacterIterator java.awt.im.InputMethodRequests.getSelectedText(java.text.AttributedCharacterIterator$Attribute[])

    /// public abstract java.text.AttributedCharacterIterator java.awt.im.InputMethodRequests.getCommittedText(int,int,java.text.AttributedCharacterIterator$Attribute[])

}


